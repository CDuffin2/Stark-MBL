import numpy as np
import scipy
import scipy.sparse as spr
import scipy.sparse.linalg as splng
import matplotlib.pyplot as plt
from numba import jit
import time

#calculate dimensionality for half filling
@jit
def Binom(n,k):
    ret = 1
    for i in range(min(k,n-k)):
        ret *= n-i
        ret /= i+1
    return ret

#state to label
@jit
def S2L(L,l_vec):
    N = L/2
    l_counter = 1
    n_counter = N
    for i in range(L):
        if l_vec[i] == 0:
            l_counter += Binom(L-(i+1),n_counter-1)
        if l_vec[i] == 1:
            n_counter -= 1
        if n_counter == 0:
            return l_counter

#label to state
@jit
def L2S(L,l):
    N = L/2
    n_counter = N
    l_counter = l
    l_vec = np.zeros(L)
    for i in range(L):
        binom = Binom(L-(i+1),n_counter-1)
        if n_counter == 0:
            l_vec[i] = 0
            continue
        if l_counter > binom:
            l_vec[i] = 0
            l_counter -= binom
            continue
        if l_counter <= binom:
            l_vec[i] = 1
            n_counter -= 1
    return l_vec

#state to label for subsystem
@jit
def S2L_Binary(vec,l):
    c = 0
    for i in range(l):
        if vec[l-1-i] == 1:
            c += 2**i
    return c

#generate states via hopping terms
def Hop(L,input):
    input = np.ndarray.astype(input,int) #input state
    output_lst = [] #appended list of output states
    for i in range(L-1):
        if input[i] == 1 and input[i+1] == 0: #hopping to the right
            output = np.copy(input)
            output[i] = 0
            output[i+1] = 1
            output_lst.append(output)
        if input[i] == 0 and input[i+1] == 1: #hopping to the left
            output = np.copy(input)
            output[i] = 1
            output[i+1] = 0
            output_lst.append(output)
    ns = np.shape(output_lst)[0] #number of output states
    return output_lst,ns

#diagonal elements of static Hamiltonian
def Diag(L,Dim,gamma,w,V):
    row = np.empty(Dim*L)
    col = np.empty(Dim*L)
    data = np.empty(Dim*L)
    nnz = 0
    for i in range(Dim):
        state = L2S(L,i+1) #select vector
        v = 0 #nearest-neighbour interaction counter
        g = 0 #field interaction counter
        h = 0 #disorder interaction counter
        for k in range(L):
            g = g-gamma*k*state[k] #count field interactions
            h = h+np.random.normal(0,w)*state[k] #count disorder interactions
        for k in range(L-1):
            v = v+V*state[k]*state[k+1] #count nearest-neighbour interactions
        row[nnz] = i #H[i,i] = g+h+v
        col[nnz] = i
        data[nnz] = g+h+v
        nnz += 1
    return spr.csc_matrix((data[:nnz],(row[:nnz],col[:nnz])),shape=(Dim,Dim))

#off-diagonal elements of static Hamiltonian
def Offdiag(L,Dim,J):
    row = np.empty(Dim*L)
    col = np.empty(Dim*L)
    data = np.empty(Dim*L)
    nnz = 0
    for i in range(Dim):
        input = L2S(L,i+1) #generate Fock state
        output_lst,ns = Hop(L,input) #generate new states via hopping
        for k in range(ns): #loop through all states generated by hopping
            output = output_lst[k] #select output state
            j = int(S2L(L,output)-1) #convert to label
            row[nnz] = i #H[i,j] = J
            col[nnz] = j
            data[nnz] = J
            nnz += 1
    return spr.csc_matrix((data[:nnz],(row[:nnz],col[:nnz])),shape=(Dim,Dim))

#calculate eigenvectors
def Eigenvectors(L,Dim,J,gamma,w,V,T_0,T_1):
    H_0 = Diag(L,Dim,gamma,w,V) #diagonal part of Hamiltonian
    H_1 = Offdiag(L,Dim,J)
    A = np.diag(np.exp(np.diag(-1j*H_0.todense()*T_0))) #exponentiate diagonal matrix
    B = scipy.linalg.expm(-1j*H_1.todense()*T_1) #exponentiate off-diagonal matrix
    F = A@B #Floquet operator
    U = np.linalg.eig(F)[1] #calculate eigenvectors
    return np.array(U)

def EEV(L,Dim,J,gamma,w,V,T_0,T_1,n_site):
    U = Eigenvectors(L,Dim,J,gamma,w,V,T_0,T_1)
    n = np.zeros(Dim)
    eev = np.zeros(Dim)
    for j in range(Dim):
        vec = L2S(L,j) #obtain Fock state
        n[j] = vec[n_site] #obtain number density for Fock state
    for i in range(Dim): #eigenstate index
        for j in range(Dim): #Fock state index
            eev[i] = eev[i]+n[j]*np.abs(U[j,i])**2 #number density expectation value
    return eev

def Main():
    L,J,V,gamma,w,lst,T_0_lst,T_1,n_site,ng = Parameters()
    Dim = int(Binom(L,L/2))
    eev = np.zeros((ng,Dim))
    H_0 = Diag(L,Dim,gamma,w,V)
    for i in range(ng):
        T_0 = T_0_lst[i]
        eev[i] = EEV(L,Dim,J,gamma,w,V,T_0,T_1,n_site) #obtain eevs
    return eev

def Plot(eev):
    L,J,V,gamma,w,lst,T_0_lst,T_1,n_site,ng = Parameters()
    plt.figure(figsize=(9,9),dpi=80)
    plt.suptitle(r'$T_1={}$'.format(T_1),y=0.95,fontsize=20)
    for i in range(ng):
        plt.subplot(2,2,i+1)
        plt.plot(eev[i],'b .',markersize=1)
        if i > 1:
            plt.xlabel('quasienergy')
        if i == 0 or i == 2:
            plt.ylabel(r'$\langle b_3^{\dag}b_3\rangle$')
        plt.title(r'$\gamma T_0/2\pi={}$'.format(lst[i]))
        plt.ylim([0,1])
        ax = plt.gca()
        ax.set_xticklabels([])
        ax.set_box_aspect(1)
    plt.show()

def Parameters():
    L = 10 #system size
    J = 0.5 #hopping amplitude
    V = 0.5 #interaction strength
    gamma = 5 #potential strength
    w = 0.05 #disorder
    lst = np.array([0.5,1.0,1.5,2.0])
    T_0_lst = 2*np.pi*lst/gamma #unkicked period
    T_1 = 0.5 #kicked period
    n_site = 3 #site index for number density operator
    return L,J,V,gamma,w,lst,T_0_lst,T_1,n_site,np.size(lst)

start = time.time()
eev = Main()
end = time.time()
print("Runtime:", (end-start)/60, "minutes")
Plot(eev)